### Data model

The data model is heavily driven by the DDD-terms [entity, value objects and aggregates][dddBlocks].
In design terms, value objects may still posses some kind of unique identifier (primary key), but 
only for the technical reason that value objects may have many-to-one- or many-to-many relationships
to other objects and may be stored in relational databases. For one-to-one relations involving value 
objects, rather than destructuring the data into two tables, the "owning" side should embed the 
"owned" side and store all information in a single table. The id of a value object should never be
exposed beyond the persistence layer.

#### `UUID` for identification
Each entity in the domain should be identifiable by a 
[Universally unique identifier (`UUID`)][uuid], specifically
[version 4 random `UUID`s][[randomUuid]]. The `UUID` of an entity should be unique for a entity of a
given type, but entities of different types can have the same `UUID`.

#### Timestamps and dates

Points in time should always be represented as a timestamp without timezone information. It is
implicitly assumed that the timezone of a timestamp is a [UTC][utc] timestamp. For external
transfer, we want to use a [ISO 8601][iso8601] UTC timestamp, the corresponding format string is

    yyyy-MM-dd'T'HH:mm:ss.SSS'Z'
examples are:

    2020-01-01T00:00:00.000Z
    1970-01-01T00:00:00.000Z
    1985-02-18T12:16:25.666Z
   
For dates, we use the simplified template

    yyyy-MM-dd
examples are:

    2020-01-01
    1970-01-01
    1985-02-18
#### Database rules

Database operations should be, as far as possible, ANSI-SQL conform. Exceptions are:

- indexes
- `UUID` data type (tbd, [PostgreSQL has a dedicated data type for `UUID`s][postgresqlDataTypes], 
   [MySQL stores `UUID`s as `BINARY(16)`][mysqlUuid], other database providers may store them as 
   `BINARY(16)`,
   [JPA can be instructed to use a `BINARY(16)` as target column for `UUID`s][jpaUuidBin16]).

Due to the fact that most database providers do not support version 4 `UUID` generation, `UUID`s 
should not be generated by the database, but by the application.

Since trigger syntax is database-provider specific, triggers must not be used.

Table- and column-names are written in [`(lower_)snake_case`][snakeCase]. Table names should be 
written in singular, e.g. `user` instead of `users`.

The column holding the primary key should be named `id`.

Constraints and indexes should be named after the scheme 
`[table_name]_[constraint-type](_[column_name])+` with `containt-type` being one of:

- `pk` for primary key constraints
- `fk` for foreign key constraints
- `unique` for unique constraint
- `idx` for indices

For example, if on a table `my_table` the column-pair `attribute_one` and `attribute_two` should be 
constraint to be unique, the corresponding constraint would be called:

    my_table_unique_attribute_one_attribute_two
Colums holding foreign key constraints should always define indexes on the foreign key columns.


#### General constraints

If not otherwise noted, all `String`s are limited to 255 characters. This is enforced database-wise.

Exact points in time are always stored in UTC time format and without timezone information (thus UTC
is always assumed).

#### Documentation Resources

The data model is shown in the [UML diagram][uml]. The corresponding database schema is shown in the
[ERD diagram][erd].

#### Base data model

Every entity should have an attribute `id` that is a version 4 random `UUID`. Once 
assigned, the `id` is immutable. The `id` is for service-internal use only and should not be exposed
to external actors. Other unique identifiers, like names, should be exposed to external actors.

---
Open question:

Is a microservice in the same subsystem an "*external service*" or does it "*know*" of the `id`s
of not-owned entities? 
---

#### Base for all entities

To avoid boilerplate code, we want to use the class `BaseEntity` as base for all entities (including
aggregates). This entity has two fields:
- `id` of type `UUID`, and
- `created` of type `Instant`. 

The time in `created` is always stored as timestamp without timezone, and UTC timezone is assumed.

#### User data model

The information stored for a person using the application ( a *user*) is split into two classes:

- A `User` class, that stores all required information, as well as a reference to
- a `UserProfile` class, holding optional value of a `User`.

Since `UserProfile` is a value object and has a 1:1 relationship to `User`, the attributes of 
`UserProfile` will be embedded into the corresponding `user`-table.

##### `User` class

---
Quick overview:<br>
[Isolated UML][userUml]<br>
[Isolated ERD][userErd]<br>
---

A `User` is an entity and an aggregate object, holding the `id`s of other entities a `User` 
possesses or takes part in(for example `Character`s or `Game`s).
 
To external actors, a `User` is identified by her or his unique `name`. Once set, the `name` cannot
be changed. The `name` is a `String` and is constrained by the regular expression `[0-9a-zA-Z\-]+`.
Furthermore, each `User` has a unique `email`, also represented by a `String`. 

The attributes discussed above are the only required attributes for a `User`. For login purposes,
a `User` can use either her or his `name` or her or his `email`.

##### UserProfile class

The `UserProfile` holds mutable and optional attributes associated with a `User`. There is a 1:1 
relation between `User`s and their `UserProfile`s. Furthermore, `UserProfile`s are value objects.

Fields included in the `UserProfile` are:
- `displayName`: A `string` used in all social interaction that is not constrained. If not set,
  the application will use the `name` as implicit `displayName`.
- `firstName`, `lastName`: the first and last name of a user, as `String`.
- `birthday`: the birthday of a user, represented as `LocalDate`.
- `bio`: A free-text biography the user can fill out, stored as `String`.
- `hoursPlayed`: An application-managed property, counting the hours a user has played in the 
   application. Stored as `int`.
- `avatar`: an avatar image. Type is to be discussed.

---
Open questions:
- Do we want the `UserProfile`-class? It leads to problems with Lombok and mapstuct if we want to
  flatten the object structure in the boundary. Nothing impossible, but annyoing since the mapping 
  of each property in `UserProfile` must be explicitly mapped to a target property in the boundary-
  builer.
  - Pro:
    Nicer (and possibly semnantically sounder) definition of `User`.
  - Con:
    Problem(s) with Lombok and mapstruct.
- What type do we want to use for the `avatar`?
- Do we want to store the avatars in the database?
  - Pros: 
    - If we store the images in the database, we do not need additional (shared) storage.
    - A backup of the database is sufficient for disaster recovery.
    - We do not need aditional logic for mapping avatar-references in the database to files in the file system.
  - Cons:<br>
    Blobs in database =/

[dddBlocks]: https://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks
[uuid]: https://en.wikipedia.org/wiki/Universally_unique_identifier
[randomUuid]: https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)
[utc]: https://en.wikipedia.org/wiki/Coordinated_Universal_Time
[iso8601]: https://en.wikipedia.org/wiki/Coordinated_Universal_Time
[postgresqlDataTypes]: https://www.postgresqltutorial.com/postgresql-data-types/
[mysqlUuid]: https://mysqlserverteam.com/mysql-8-0-uuid-support/
[uuid-ossp]: https://www.postgresql.org/docs/10/uuid-ossp.html
[jpaUuidBin16]: https://phauer.com/2016/uuids-hibernate-mysql/
[snakeCase]: https://en.wikipedia.org/wiki/Snake_case
[uml]: UML.puml
[erd]: ERD.
[userUml]: userUML.puml
[userErd]: userERD.puml